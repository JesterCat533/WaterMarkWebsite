<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulk Watermark App</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- JSZip CDN for creating ZIP files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* Custom styles for the app */
        body {
            /* Purple to Blue gradient, rotating/moving */
            background: linear-gradient(135deg, #8A2BE2, #4169E1, #00BFFF); /* Purple, RoyalBlue, DeepSkyBlue */
            background-size: 400% 400%;
            animation: gradientAnimation 15s ease infinite;
            font-family: 'Inter', sans-serif;
            color: #333;
            min-height: 100vh; /* Ensure it covers the whole viewport */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column; /* Allows content to stack if narrower */
        }

        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1200px;
            margin: auto;
            padding: 2rem;
            background-color: rgba(255, 255, 255, 0.95); /* Slightly transparent white */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            backdrop-filter: blur(5px); /* Subtle blur effect on background */
            width: 100%; /* Ensure container takes full width on small screens */
        }
        .tab-button {
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: #e2e8f0; /* bg-blue-100 */
            color: #2d3748; /* text-gray-800 */
            border: none; /* Remove default button border */
        }
        .tab-button.active {
            background-color: #3b82f6; /* bg-blue-500 */
            color: #ffffff; /* text-white */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .control-group {
            @apply mb-4 p-4 bg-gray-50 rounded-lg shadow-sm;
        }
        .control-group label {
            @apply block text-sm font-medium text-gray-700 mb-1;
        }
        .control-group input[type="range"],
        .control-group input[type="number"] {
            @apply w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500;
        }
        .preview-area {
            @apply relative overflow-hidden rounded-lg shadow-lg bg-gray-200 flex justify-center items-center;
            min-height: 400px;
            max-height: 550px; /* Constrain max height for dynamic layout */
            border: 1px solid #cbd5e0;
            flex-grow: 1; /* Allow it to grow */
            margin-bottom: 1.5rem; /* Space below preview */
        }
        #photoCanvas, #videoPreview {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; /* Ensure content fits without distortion */
            /* Added for better centering inside flex container */
            width: auto;
            height: auto;
        }
        #watermarkPhotoOverlay, #watermarkVideoOverlay {
            position: absolute;
            pointer-events: none; /* Allows clicks to pass through to the video/canvas */
            /* Removed transform-origin here to rely purely on top/left positioning */
        }
        .file-upload-box {
            @apply border-2 border-dashed border-gray-300 rounded-lg p-6 text-center cursor-pointer hover:border-blue-500 transition duration-200 ease-in-out;
        }
        .file-upload-box input {
            display: none;
        }
        .thumbnail-container {
            @apply flex flex-wrap gap-4 mt-4;
            max-height: 150px; /* Limit height of thumbnail container */
            overflow-y: auto; /* Add scroll if many thumbnails */
        }
        .thumbnail {
            @apply relative w-24 h-24 border-2 border-gray-300 rounded-md overflow-hidden cursor-pointer;
            flex-shrink: 0; /* Prevent thumbnails from shrinking */
        }
        .thumbnail.selected {
            @apply border-blue-500 ring-2 ring-blue-500;
        }
        .thumbnail img, .thumbnail video {
            @apply w-full h-full object-cover;
        }
        .action-button {
            @apply bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-200 ease-in-out;
            border: none;
            cursor: pointer;
        }
        /* Specific style for download button */
        .action-button.download {
            @apply bg-green-600 hover:bg-green-700;
        }
        .message-box {
            @apply fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50;
        }
        .message-content {
            @apply bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center;
        }
        .message-box button {
            @apply mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md;
        }
        .grid.grid-cols-1.md\:grid-cols-2 {
            @apply flex flex-col md:flex-row; /* Ensure vertical stack on small screens, horizontal on medium+ */
        }
        .grid.grid-cols-1.md\:grid-cols-2 > div {
            @apply flex flex-col; /* Make columns use flexbox */
        }
        .grid.grid-cols-1.md\:grid-cols-2 > div:first-child {
            @apply pr-0 md:pr-4; /* Add padding between columns on medium+ */
        }
        .grid.grid-cols-1.md\:grid-cols-2 > div:last-child {
            @apply pl-0 md:pl-4; /* Add padding between columns on medium+ */
            flex-shrink: 0; /* Prevent controls from shrinking */
            width: 100%; /* Full width on mobile */
            max-width: none; /* No max width on mobile */
            padding-top: 1.5rem; /* Space between upload/preview and controls on mobile */
            border-top: 1px solid #e2e8f0; /* Separator on mobile */
        }
        @media (min-width: 768px) {
            .grid.grid-cols-1.md\:grid-cols-2 > div:last-child {
                border-top: none; /* Remove separator on desktop */
                padding-top: 0;
                width: 50%; /* Half width on desktop */
                max-width: 500px; /* Constrain max width for controls on desktop */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-4xl font-extrabold text-gray-900 text-center mb-8 pt-6">Watermark Master</h1>

        <div class="flex justify-center mb-8">
            <button id="photoTab" class="tab-button active mr-4">Watermark Photos</button>
            <button id="videoTab" class="tab-button">Watermark Videos</button>
        </div>

        <!-- Message Box (Hidden by default) -->
        <div id="messageBox" class="message-box hidden">
            <div class="message-content">
                <p id="messageText" class="text-lg text-gray-800"></p>
                <button onclick="hideMessageBox()">OK</button>
            </div>
        </div>

        <!-- Photo Watermark Section -->
        <div id="photoSection" class="p-6">
            <h2 class="text-2xl font-semibold text-gray-800 mb-6">Bulk Photo Watermark</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <!-- Upload Area -->
                <div>
                    <button id="uploadPhotosBtn" class="action-button w-full mb-4">Upload Photos</button>
                    <div class="file-upload-box mb-6" id="photoUploadBox">
                        <input type="file" id="photoInput" accept="image/*" multiple>
                        <p class="text-gray-600">Or drag & drop photos here</p>
                        <p class="text-gray-500 text-sm mt-1">(Supports JPG, PNG, GIF)</p>
                    </div>
                    <div class="thumbnail-container" id="photoThumbnails">
                        <!-- Photo thumbnails will be injected here -->
                    </div>

                    <button id="uploadWatermarkPhotoBtn" class="action-button w-full mt-6 mb-4">Upload Watermark PNG</button>
                    <div class="file-upload-box mb-6" id="watermarkPhotoUploadBox">
                        <input type="file" id="watermarkPhotoInput" accept="image/png">
                        <p class="text-gray-600">Or drag & drop PNG watermark</p>
                        <p class="text-gray-500 text-sm mt-1">(Only PNG files)</p>
                    </div>
                    <img id="watermarkPhotoPreview" src="#" alt="Watermark Preview" class="hidden mt-4 w-24 h-24 object-contain rounded-md border border-gray-200">
                </div>

                <!-- Preview and Controls -->
                <div class="flex flex-col">
                    <h3 class="text-xl font-medium text-gray-700 mb-4">Live Preview (Selected Photo)</h3>
                    <div class="preview-area mb-6">
                        <canvas id="photoCanvas"></canvas>
                        <img id="watermarkPhotoOverlay" src="#" alt="Watermark" class="absolute hidden">
                    </div>

                    <div class="control-group">
                        <label for="photoWatermarkX">Position X:</label>
                        <input type="range" id="photoWatermarkX" min="0" max="100" value="50">
                        <span id="photoWatermarkXValue" class="text-sm text-gray-600">50%</span>
                    </div>

                    <div class="control-group">
                        <label for="photoWatermarkY">Position Y:</label>
                        <input type="range" id="photoWatermarkY" min="0" max="100" value="50">
                        <span id="photoWatermarkYValue" class="text-sm text-gray-600">50%</span>
                    </div>

                    <div class="control-group">
                        <label for="photoWatermarkSize">Size:</label>
                        <input type="range" id="photoWatermarkSize" min="1" max="100" value="20">
                        <span id="photoWatermarkSizeValue" class="text-sm text-gray-600">20%</span>
                    </div>

                    <div class="control-group">
                        <label for="photoWatermarkOpacity">Opacity:</label>
                        <input type="range" id="photoWatermarkOpacity" min="0" max="100" value="80">
                        <span id="photoWatermarkOpacityValue" class="text-sm text-gray-600">80%</span>
                    </div>

                    <!-- Button text changed to reflect ZIP download -->
                    <button id="applyPhotoWatermark" class="action-button w-full mt-4">Download All Watermarked Photos (ZIP)</button>
                    <p class="text-sm text-gray-500 mt-2 text-center">
                        <strong class="text-red-500">Note:</strong> All processed photos will be downloaded in a single ZIP file. Directly saving to a chosen folder or replacing originals is not possible from the browser.
                    </p>
                </div>
            </div>
        </div>

        <!-- Video Watermark Section -->
        <div id="videoSection" class="p-6 hidden">
            <h2 class="text-2xl font-semibold text-gray-800 mb-6">Bulk Video Watermark</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <!-- Upload Area -->
                <div>
                    <button id="uploadVideosBtn" class="action-button w-full mb-4">Upload Videos</button>
                    <div class="file-upload-box mb-6" id="videoUploadBox">
                        <input type="file" id="videoInput" accept="video/*" multiple>
                        <p class="text-gray-600">Or drag & drop videos here</p>
                        <p class="text-gray-500 text-sm mt-1">(Supports MP4, WebM, Ogg)</p>
                    </div>
                    <div class="thumbnail-container" id="videoThumbnails">
                        <!-- Video thumbnails will be injected here -->
                    </div>

                    <button id="uploadWatermarkVideoBtn" class="action-button w-full mt-6 mb-4">Upload Watermark PNG</button>
                    <div class="file-upload-box mb-6" id="watermarkVideoUploadBox">
                        <input type="file" id="watermarkVideoInput" accept="image/png">
                        <p class="text-gray-600">Or drag & drop PNG watermark</p>
                        <p class="text-gray-500 text-sm mt-1">(Only PNG files)</p>
                    </div>
                    <img id="watermarkVideoPreview" src="#" alt="Watermark Preview" class="hidden mt-4 w-24 h-24 object-contain rounded-md border border-gray-200">
                </div>

                <!-- Preview and Controls -->
                <div class="flex flex-col">
                    <h3 class="text-xl font-medium text-gray-700 mb-4">Live Preview (Selected Video)</h3>
                    <div class="preview-area mb-6">
                        <video id="videoPreview" controls muted loop></video>
                        <img id="watermarkVideoOverlay" src="#" alt="Watermark" class="absolute hidden">
                    </div>

                    <div class="control-group">
                        <label for="videoWatermarkX">Position X:</label>
                        <input type="range" id="videoWatermarkX" min="0" max="100" value="50">
                        <span id="videoWatermarkXValue" class="text-sm text-gray-600">50%</span>
                    </div>

                    <div class="control-group">
                        <label for="videoWatermarkY">Position Y:</label>
                        <input type="range" id="videoWatermarkY" min="0" max="100" value="50">
                        <span id="videoWatermarkYValue" class="text-sm text-gray-600">50%</span>
                    </div>

                    <div class="control-group">
                        <label for="videoWatermarkSize">Size:</label>
                        <input type="range" id="videoWatermarkSize" min="1" max="100" value="20">
                        <span id="videoWatermarkSizeValue" class="text-sm text-gray-600">20%</span>
                    </div>

                    <div class="control-group">
                        <label for="videoWatermarkOpacity">Opacity:</label>
                        <input type="range" id="videoWatermarkOpacity" min="0" max="100" value="80">
                        <span id="videoWatermarkOpacityValue" class="text-sm text-gray-600">80%</span>
                    </div>

                    <div class="control-group">
                        <label for="videoWatermarkDuration">Watermark Duration (seconds):</label>
                        <input type="number" id="videoWatermarkDuration" min="1" value="5" class="w-full">
                    </div>

                    <div class="control-group flex items-center">
                        <input type="checkbox" id="videoFadeEffect" class="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                        <label for="videoFadeEffect" class="text-sm font-medium text-gray-700">Add Fade In/Out Effect</label>
                    </div>

                    <div class="control-group flex items-center">
                        <input type="checkbox" id="videoBlurEffect" class="mr-2 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" disabled>
                        <label for="videoBlurEffect" class="text-sm font-medium text-gray-700">Add Background Blur on Fade</label>
                    </div>

                    <button id="applyVideoWatermark" class="action-button w-full mt-4">Download All Videos (Simulated Watermark, ZIP)</button>
                    <p class="text-sm text-gray-500 mt-2 text-center">
                        <strong class="text-red-500">WARNING:</strong> Full video watermarking with complex effects (fade, blur) is very resource-intensive and not fully supported for bulk operations in the browser without specialized libraries that are too large for this demo. This will download your **original videos in a ZIP** as a placeholder. For actual video processing, a powerful server-side solution is required.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for elements
        const photoTab = document.getElementById('photoTab');
        const videoTab = document.getElementById('videoTab');
        const photoSection = document.getElementById('photoSection');
        const videoSection = document.getElementById('videoSection');

        // New button references
        const uploadPhotosBtn = document.getElementById('uploadPhotosBtn');
        const uploadWatermarkPhotoBtn = document.getElementById('uploadWatermarkPhotoBtn');
        const uploadVideosBtn = document.getElementById('uploadVideosBtn');
        const uploadWatermarkVideoBtn = document.getElementById('uploadWatermarkVideoBtn');

        const photoInput = document.getElementById('photoInput');
        const photoUploadBox = document.getElementById('photoUploadBox');
        const photoThumbnails = document.getElementById('photoThumbnails');
        const photoCanvas = document.getElementById('photoCanvas');
        const photoCtx = photoCanvas.getContext('2d');
        const watermarkPhotoInput = document.getElementById('watermarkPhotoInput');
        const watermarkPhotoPreview = document.getElementById('watermarkPhotoPreview');
        const watermarkPhotoOverlay = document.getElementById('watermarkPhotoOverlay');

        const videoInput = document.getElementById('videoInput');
        const videoUploadBox = document.getElementById('videoUploadBox'); // Corrected typo here
        const videoThumbnails = document.getElementById('videoThumbnails');
        const videoPreview = document.getElementById('videoPreview');
        const watermarkVideoInput = document.getElementById('watermarkVideoInput');
        const watermarkVideoPreview = document.getElementById('watermarkVideoPreview');
        const watermarkVideoOverlay = document.getElementById('watermarkVideoOverlay');

        // Control sliders and their value displays for photos
        const photoWatermarkX = document.getElementById('photoWatermarkX');
        const photoWatermarkXValue = document.getElementById('photoWatermarkXValue');
        const photoWatermarkY = document.getElementById('photoWatermarkY');
        const photoWatermarkYValue = document.getElementById('photoWatermarkYValue');
        const photoWatermarkSize = document.getElementById('photoWatermarkSize');
        const photoWatermarkSizeValue = document.getElementById('photoWatermarkSizeValue');
        const photoWatermarkOpacity = document.getElementById('photoWatermarkOpacity');
        const photoWatermarkOpacityValue = document.getElementById('photoWatermarkOpacityValue');

        // Control sliders and their value displays for videos
        const videoWatermarkX = document.getElementById('videoWatermarkX');
        const videoWatermarkXValue = document.getElementById('videoWatermarkXValue');
        const videoWatermarkY = document.getElementById('videoWatermarkY');
        const videoWatermarkYValue = document.getElementById('videoWatermarkYValue');
        const videoWatermarkSize = document.getElementById('videoWatermarkSize');
        const videoWatermarkSizeValue = document.getElementById('videoWatermarkSizeValue');
        const videoWatermarkOpacity = document.getElementById('videoWatermarkOpacity');
        const videoWatermarkOpacityValue = document.getElementById('videoWatermarkOpacityValue');
        const videoWatermarkDuration = document.getElementById('videoWatermarkDuration');
        const videoFadeEffect = document.getElementById('videoFadeEffect');
        const videoBlurEffect = document.getElementById('videoBlurEffect');

        const applyPhotoWatermarkBtn = document.getElementById('applyPhotoWatermark'); // This button now handles bulk downloads
        const applyVideoWatermarkBtn = document.getElementById('applyVideoWatermark');

        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');

        let uploadedPhotos = [];
        let uploadedVideos = [];
        let currentWatermarkPhoto = null; // Stores Image object for photo watermark
        let currentWatermarkVideo = null; // Stores Image object for video watermark
        let currentSelectedPhotoIndex = -1;
        let currentSelectedVideoIndex = -1;

        // --- Message Box Functions ---
        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.classList.remove('hidden');
        }

        function hideMessageBox() {
            messageBox.classList.add('hidden');
        }

        // --- Tab Switching Logic ---
        function switchTab(activeTab) {
            if (activeTab === 'photo') {
                photoTab.classList.add('active');
                videoTab.classList.remove('active');
                photoSection.classList.remove('hidden');
                videoSection.classList.add('hidden');
            } else {
                videoTab.classList.add('active');
                photoTab.classList.remove('active');
                videoSection.classList.remove('hidden');
                photoSection.classList.add('hidden');
            }
        }

        photoTab.addEventListener('click', () => switchTab('photo'));
        videoTab.addEventListener('click', () => switchTab('video'));

        // --- Photo Watermark Logic ---

        // Handle Photo Upload via button click
        uploadPhotosBtn.addEventListener('click', () => photoInput.click());
        // Handle Photo Upload via drag & drop / input change
        photoUploadBox.addEventListener('dragover', (e) => { e.preventDefault(); photoUploadBox.classList.add('border-blue-500'); });
        photoUploadBox.addEventListener('dragleave', () => { photoUploadBox.classList.remove('border-blue-500'); });
        photoUploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            photoUploadBox.classList.remove('border-blue-500');
            handlePhotoFiles(e.dataTransfer.files);
        });
        photoInput.addEventListener('change', (e) => handlePhotoFiles(e.target.files));

        function handlePhotoFiles(files) {
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (file.type.startsWith('image/')) {
                    uploadedPhotos.push(file);
                    addPhotoThumbnail(file, uploadedPhotos.length - 1);
                } else {
                    console.warn(`Skipping non-image file: ${file.name}`);
                }
            }
            // Automatically select the first uploaded photo if none is selected
            if (currentSelectedPhotoIndex === -1 && uploadedPhotos.length > 0) {
                selectPhotoForPreview(0);
            }
        }

        function addPhotoThumbnail(file, index) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const imgContainer = document.createElement('div');
                imgContainer.classList.add('thumbnail', 'rounded-md', 'overflow-hidden', 'relative', 'cursor-pointer', 'border-2', 'border-gray-300');
                imgContainer.dataset.index = index;
                imgContainer.innerHTML = `<img src="${e.target.result}" alt="Photo Thumbnail">`;
                photoThumbnails.appendChild(imgContainer);

                imgContainer.addEventListener('click', () => selectPhotoForPreview(index));
                // If it's the first image added and no image is currently selected, select it
                if (index === 0 && currentSelectedPhotoIndex === -1) {
                    selectPhotoForPreview(0);
                }
            };
            reader.readAsDataURL(file);
        }

        function selectPhotoForPreview(index) {
            // Remove 'selected' class from previous thumbnail
            if (currentSelectedPhotoIndex !== -1) {
                const prevSelected = photoThumbnails.querySelector(`.thumbnail[data-index="${currentSelectedPhotoIndex}"]`);
                if (prevSelected) {
                    prevSelected.classList.remove('selected');
                }
            }

            // Add 'selected' class to new thumbnail
            const newSelected = photoThumbnails.querySelector(`.thumbnail[data-index="${index}"]`);
            if (newSelected) {
                newSelected.classList.add('selected');
            }

            currentSelectedPhotoIndex = index;
            const file = uploadedPhotos[index];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Set canvas dimensions to match image, maintaining aspect ratio within container
                        const previewArea = photoCanvas.closest('.preview-area');
                        const maxWidth = previewArea.clientWidth;
                        const maxHeight = previewArea.clientHeight;

                        let aspectRatio = img.width / img.height;
                        let newWidth = img.width;
                        let newHeight = img.height;

                        // Scale to fit within preview area
                        if (img.width > maxWidth || img.height > maxHeight) {
                            if (maxWidth / maxHeight > aspectRatio) { // Image is taller than preview aspect
                                newHeight = maxHeight;
                                newWidth = newHeight * aspectRatio;
                            } else { // Image is wider than preview aspect
                                newWidth = maxWidth;
                                newHeight = newWidth / aspectRatio;
                            }
                        } else {
                            newWidth = img.width;
                            newHeight = img.height;
                        }

                        photoCanvas.width = newWidth;
                        photoCanvas.height = newHeight;

                        photoCtx.clearRect(0, 0, photoCanvas.width, photoCanvas.height);
                        photoCtx.drawImage(img, 0, 0, photoCanvas.width, photoCanvas.height);
                        drawPhotoWatermark(); // Redraw watermark after photo loads
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        // Handle Watermark PNG Upload for Photos via button click
        uploadWatermarkPhotoBtn.addEventListener('click', () => watermarkPhotoInput.click());
        // Handle Watermark PNG Upload for Photos via drag & drop / input change
        watermarkPhotoUploadBox.addEventListener('dragover', (e) => { e.preventDefault(); watermarkPhotoUploadBox.classList.add('border-blue-500'); });
        watermarkPhotoUploadBox.addEventListener('dragleave', () => { watermarkPhotoUploadBox.classList.remove('border-blue-500'); });
        watermarkPhotoUploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            watermarkPhotoUploadBox.classList.remove('border-blue-500');
            handleWatermarkFile(e.dataTransfer.files[0], 'photo');
        });
        watermarkPhotoInput.addEventListener('change', (e) => handleWatermarkFile(e.target.files[0], 'photo'));

        function handleWatermarkFile(file, type) {
            if (file && file.type === 'image/png') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        if (type === 'photo') {
                            currentWatermarkPhoto = img;
                            watermarkPhotoPreview.src = e.target.result;
                            watermarkPhotoPreview.classList.remove('hidden');
                            watermarkPhotoOverlay.src = e.target.result;
                            watermarkPhotoOverlay.classList.remove('hidden');
                            drawPhotoWatermark();
                        } else if (type === 'video') {
                            currentWatermarkVideo = img;
                            watermarkVideoPreview.src = e.target.result;
                            watermarkVideoPreview.classList.remove('hidden');
                            watermarkVideoOverlay.src = e.target.result;
                            watermarkVideoOverlay.classList.remove('hidden');
                            updateVideoWatermarkOverlay();
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                showMessageBox('Please upload a PNG file for the watermark.');
            }
        }

        // Draw Watermark on Photo Canvas (live update)
        function drawPhotoWatermark() {
            if (!currentWatermarkPhoto || currentSelectedPhotoIndex === -1 || !uploadedPhotos[currentSelectedPhotoIndex]) return;

            const img = new Image();
            img.onload = () => {
                 const previewArea = photoCanvas.closest('.preview-area');
                 const maxWidth = previewArea.clientWidth;
                 const maxHeight = previewArea.clientHeight;

                 let aspectRatio = img.width / img.height;
                 let newWidth = img.width;
                 let newHeight = img.height;

                 // Scale to fit within preview area
                 if (img.width > maxWidth || img.height > maxHeight) {
                     if (maxWidth / maxHeight > aspectRatio) {
                         newHeight = maxHeight;
                         newWidth = newHeight * aspectRatio;
                     } else {
                         newWidth = maxWidth;
                         newHeight = newWidth / aspectRatio;
                     }
                 } else {
                     newWidth = img.width;
                     newHeight = img.height;
                 }

                 photoCanvas.width = newWidth;
                 photoCanvas.height = newHeight;

                photoCtx.clearRect(0, 0, photoCanvas.width, photoCanvas.height);
                photoCtx.drawImage(img, 0, 0, photoCanvas.width, photoCanvas.height);

                // Calculate watermark position and size based on canvas dimensions
                const watermarkSizeRatio = photoWatermarkSize.value / 100; // 0.01 to 1
                const watermarkWidth = currentWatermarkPhoto.width * watermarkSizeRatio;
                const watermarkHeight = currentWatermarkPhoto.height * watermarkSizeRatio;

                const posX = (photoWatermarkX.value / 100) * (photoCanvas.width - watermarkWidth);
                const posY = (photoWatermarkY.value / 100) * (photoCanvas.height - watermarkHeight);

                photoCtx.globalAlpha = photoWatermarkOpacity.value / 100;
                photoCtx.drawImage(currentWatermarkPhoto, posX, posY, watermarkWidth, watermarkHeight);
                photoCtx.globalAlpha = 1; // Reset opacity
            };
            img.src = URL.createObjectURL(uploadedPhotos[currentSelectedPhotoIndex]);
        }

        // Add event listeners for photo watermark controls
        photoWatermarkX.addEventListener('input', () => { photoWatermarkXValue.textContent = `${photoWatermarkX.value}%`; drawPhotoWatermark(); });
        photoWatermarkY.addEventListener('input', () => { photoWatermarkYValue.textContent = `${photoWatermarkY.value}%`; drawPhotoWatermark(); });
        photoWatermarkSize.addEventListener('input', () => { photoWatermarkSizeValue.textContent = `${photoWatermarkSize.value}%`; drawPhotoWatermark(); });
        photoWatermarkOpacity.addEventListener('input', () => { photoWatermarkOpacityValue.textContent = `${photoWatermarkOpacity.value}%`; drawPhotoWatermark(); });

        // MODIFIED: applyPhotoWatermarkBtn now handles bulk ZIP download
        applyPhotoWatermarkBtn.addEventListener('click', async () => {
            if (uploadedPhotos.length === 0) {
                showMessageBox('Please upload photos first.');
                return;
            }
            if (!currentWatermarkPhoto) {
                showMessageBox('Please upload a watermark PNG first.');
                return;
            }

            showMessageBox('Processing photos and zipping them. This may take a moment...');

            const zip = new JSZip();
            const watermarkDetails = {
                img: currentWatermarkPhoto,
                x: photoWatermarkX.value,
                y: photoWatermarkY.value,
                size: photoWatermarkSize.value,
                opacity: photoWatermarkOpacity.value
            };

            for (let i = 0; i < uploadedPhotos.length; i++) {
                const file = uploadedPhotos[i];
                const processedBlob = await processPhotoToBlob(file, watermarkDetails);
                // Clean up file name for zip entry (remove path, replace spaces etc.)
                const originalFileName = file.name;
                const extension = originalFileName.split('.').pop();
                const baseName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
                const zipFileName = `watermarked_${baseName.replace(/\s/g, '_')}.${extension}`;
                zip.file(zipFileName, processedBlob);
            }

            // Generate and download the ZIP file
            zip.generateAsync({type: "blob"})
               .then(function(content) {
                   const a = document.createElement('a');
                   a.href = URL.createObjectURL(content);
                   a.download = 'watermarked_photos.zip';
                   document.body.appendChild(a);
                   a.click();
                   document.body.removeChild(a);
                   showMessageBox('All watermarked photos have been zipped and downloaded!');
               })
               .catch(error => {
                   console.error('Error zipping photos:', error);
                   showMessageBox('Error creating ZIP file. Please try again.');
               });
        });

        // Modified: Function to process a single photo and return a Blob
        async function processPhotoToBlob(file, watermarkDetails) {
            return new Promise((resolve) => {
                const originalPhoto = new Image();
                originalPhoto.onload = () => {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');

                    // Set temporary canvas dimensions to match the original photo's dimensions
                    tempCanvas.width = originalPhoto.width;
                    tempCanvas.height = originalPhoto.height;

                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(originalPhoto, 0, 0, tempCanvas.width, tempCanvas.height);

                    // Calculate watermark position and size based on original image dimensions
                    const watermarkSizeRatio = watermarkDetails.size / 100;
                    const watermarkWidth = watermarkDetails.img.width * watermarkSizeRatio;
                    const watermarkHeight = watermarkDetails.img.height * watermarkSizeRatio;

                    const posX = (watermarkDetails.x / 100) * (tempCanvas.width - watermarkWidth);
                    const posY = (watermarkDetails.y / 100) * (tempCanvas.height - watermarkHeight);

                    tempCtx.globalAlpha = watermarkDetails.opacity / 100;
                    tempCtx.drawImage(watermarkDetails.img, posX, posY, watermarkWidth, watermarkHeight);
                    tempCtx.globalAlpha = 1;

                    // Convert canvas content to Blob
                    tempCanvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png'); // Always save as PNG for consistency and alpha channel support
                };
                originalPhoto.src = URL.createObjectURL(file);
            });
        }


        // --- Video Watermark Logic ---

        // Handle Video Upload via button click
        uploadVideosBtn.addEventListener('click', () => videoInput.click());
        // Handle Video Upload via drag & drop / input change
        videoUploadBox.addEventListener('dragover', (e) => { e.preventDefault(); videoUploadBox.classList.add('border-blue-500'); });
        videoUploadBox.addEventListener('dragleave', () => { videoUploadBox.classList.remove('border-blue-500'); });
        videoUploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            videoUploadBox.classList.remove('border-blue-500');
            handleVideoFiles(e.dataTransfer.files);
        });
        videoInput.addEventListener('change', (e) => handleVideoFiles(e.target.files));

        function handleVideoFiles(files) {
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (file.type.startsWith('video/')) {
                    uploadedVideos.push(file);
                    addVideoThumbnail(file, uploadedVideos.length - 1);
                } else {
                    console.warn(`Skipping non-video file: ${file.name}`);
                }
            }
            if (currentSelectedVideoIndex === -1 && uploadedVideos.length > 0) {
                selectVideoForPreview(0);
            }
        }

        function addVideoThumbnail(file, index) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const videoContainer = document.createElement('div');
                videoContainer.classList.add('thumbnail', 'rounded-md', 'overflow-hidden', 'relative', 'cursor-pointer', 'border-2', 'border-gray-300');
                videoContainer.dataset.index = index;
                // Use a video element for thumbnail to allow seeking to a frame if needed
                videoContainer.innerHTML = `<video src="${e.target.result}" muted preload="metadata" class="w-full h-full object-cover"></video>`;
                videoThumbnails.appendChild(videoContainer);

                videoContainer.addEventListener('click', () => selectVideoForPreview(index));
                // If it's the first video added and no video is currently selected, select it
                if (index === 0 && currentSelectedVideoIndex === -1) {
                    selectVideoForPreview(0);
                }
            };
            reader.readAsDataURL(file);
        }

        function selectVideoForPreview(index) {
            // Remove 'selected' class from previous thumbnail
            if (currentSelectedVideoIndex !== -1) {
                const prevSelected = videoThumbnails.querySelector(`.thumbnail[data-index="${currentSelectedVideoIndex}"]`);
                if (prevSelected) {
                    prevSelected.classList.remove('selected');
                }
            }

            // Add 'selected' class to new thumbnail
            const newSelected = videoThumbnails.querySelector(`.thumbnail[data-index="${index}"]`);
            if (newSelected) {
                newSelected.classList.add('selected');
            }

            currentSelectedVideoIndex = index;
            const file = uploadedVideos[index];
            if (file) {
                videoPreview.src = URL.createObjectURL(file);
                videoPreview.load(); // Load the new video
                videoPreview.play(); // Start playing immediately for preview
            }
        }

        // Handle Watermark PNG Upload for Videos via button click (reuses `handleWatermarkFile`)
        uploadWatermarkVideoBtn.addEventListener('click', () => watermarkVideoInput.click());
        // Handle Watermark PNG Upload for Videos via drag & drop / input change (reuses `handleWatermarkFile`)
        watermarkVideoUploadBox.addEventListener('click', () => watermarkVideoInput.click()); // Kept original click listener for box
        watermarkVideoUploadBox.addEventListener('dragover', (e) => { e.preventDefault(); watermarkVideoUploadBox.classList.add('border-blue-500'); });
        watermarkVideoUploadBox.addEventListener('dragleave', () => { watermarkVideoUploadBox.classList.remove('border-blue-500'); });
        watermarkVideoUploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            watermarkVideoUploadBox.classList.remove('border-blue-500');
            handleWatermarkFile(e.dataTransfer.files[0], 'video');
        });
        watermarkVideoInput.addEventListener('change', (e) => handleWatermarkFile(e.target.files[0], 'video'));

        // Updated: Update Watermark Overlay on Video (live update)
        function updateVideoWatermarkOverlay() {
            if (!currentWatermarkVideo || currentSelectedVideoIndex === -1) {
                watermarkVideoOverlay.classList.add('hidden');
                return;
            }

            watermarkVideoOverlay.classList.remove('hidden');

            const videoElement = videoPreview;
            const previewArea = videoPreview.closest('.preview-area');

            // Get the *rendered* dimensions and position of the video element within its container
            // Use offsetWidth/Height for the actual rendered size, which accounts for object-fit: contain
            const renderedVideoWidth = videoElement.offsetWidth;
            const renderedVideoHeight = videoElement.offsetHeight;

            // Calculate the actual position of the video *content* within its element if object-fit: contain
            // This needs to be precise because the watermark is positioned over the *content*, not the padding/borders
            let videoContentWidth = videoElement.videoWidth;
            let videoContentHeight = videoElement.videoHeight;

            if (videoContentWidth === 0 || videoContentHeight === 0) {
                 requestAnimationFrame(updateVideoWatermarkOverlay); // Try again next frame if metadata not loaded
                 return;
            }

            const videoAspectRatio = videoContentWidth / videoContentHeight;
            const containerAspectRatio = renderedVideoWidth / renderedVideoHeight;

            let actualVideoDisplayedWidth = renderedVideoWidth;
            let actualVideoDisplayedHeight = renderedVideoHeight;
            let offsetXWithinElement = 0;
            let offsetYWithinElement = 0;

            if (videoAspectRatio > containerAspectRatio) {
                // Video is wider than container, height is constrained
                actualVideoDisplayedHeight = renderedVideoWidth / videoAspectRatio;
                offsetYWithinElement = (renderedVideoHeight - actualVideoDisplayedHeight) / 2;
            } else {
                // Video is taller than container, width is constrained
                actualVideoDisplayedWidth = renderedVideoHeight * videoAspectRatio;
                offsetXWithinElement = (renderedVideoWidth - actualVideoDisplayedWidth) / 2;
            }


            // Calculate watermark dimensions based on the *actual displayed video content size*
            const watermarkSizeRatio = videoWatermarkSize.value / 100;
            let watermarkDisplayWidth = actualVideoDisplayedWidth * watermarkSizeRatio;
            let watermarkDisplayHeight = (watermarkDisplayWidth / currentWatermarkVideo.width) * currentWatermarkVideo.height; /* FIX: Removed typo 'currentWater' */

            // Ensure watermark doesn't exceed the displayed video dimensions
            if (watermarkDisplayHeight > actualVideoDisplayedHeight) {
                watermarkDisplayHeight = actualVideoDisplayedHeight * watermarkSizeRatio;
                watermarkDisplayWidth = (watermarkDisplayHeight / currentWatermarkVideo.height) * currentWatermarkVideo.width;
            }

            // Calculate watermark position relative to the *actual displayed video content's top-left corner*
            const wmX = (videoWatermarkX.value / 100) * (actualVideoDisplayedWidth - watermarkDisplayWidth);
            const wmY = (videoWatermarkY.value / 100) * (actualVideoDisplayedHeight - watermarkDisplayHeight);

            // Apply dimensions to overlay
            watermarkVideoOverlay.style.width = `${watermarkDisplayWidth}px`;
            watermarkVideoOverlay.style.height = `${watermarkDisplayHeight}px`;

            // Position the overlay relative to the `preview-area`'s top-left corner,
            // taking into account the video element's offset within that area
            // and the content's offset within the video element.
            const videoElementRect = videoElement.getBoundingClientRect(); // Get absolute position
            const previewAreaRect = previewArea.getBoundingClientRect(); // Get absolute position of container

            const finalLeft = videoElementRect.left - previewAreaRect.left + wmX + offsetXWithinElement;
            const finalTop = videoElementRect.top - previewAreaRect.top + wmY + offsetYWithinElement;

            watermarkVideoOverlay.style.left = `${finalLeft}px`;
            watermarkVideoOverlay.style.top = `${finalTop}px`;
            watermarkVideoOverlay.style.opacity = videoWatermarkOpacity.value / 100;

            // Ensure no conflicting transforms from previous iterations
            watermarkVideoOverlay.style.transform = 'none';
        }


        // Add event listeners for video watermark controls
        videoWatermarkX.addEventListener('input', () => { videoWatermarkXValue.textContent = `${videoWatermarkX.value}%`; updateVideoWatermarkOverlay(); });
        videoWatermarkY.addEventListener('input', () => { videoWatermarkYValue.textContent = `${videoWatermarkY.value}%`; updateVideoWatermarkOverlay(); });
        videoWatermarkSize.addEventListener('input', () => { videoWatermarkSizeValue.textContent = `${videoWatermarkSize.value}%`; updateVideoWatermarkOverlay(); });
        videoWatermarkOpacity.addEventListener('input', () => { videoWatermarkOpacityValue.textContent = `${videoWatermarkOpacity.value}%`; updateVideoWatermarkOverlay(); });

        // Event listener for video metadata loaded to get dimensions
        videoPreview.addEventListener('loadedmetadata', updateVideoWatermarkOverlay);
        // Also listen for resize events on the video element's parent, in case the layout changes
        new ResizeObserver(updateVideoWatermarkOverlay).observe(videoPreview.closest('.preview-area'));


        videoFadeEffect.addEventListener('change', () => {
            videoBlurEffect.disabled = !videoFadeEffect.checked;
            if (!videoFadeEffect.checked) {
                videoBlurEffect.checked = false; // Uncheck blur if fade is off
            }
        });

        // MODIFIED: applyVideoWatermarkBtn now handles bulk ZIP download of original videos with warning
        applyVideoWatermarkBtn.addEventListener('click', async () => {
            if (uploadedVideos.length === 0) {
                showMessageBox('Please upload videos first.');
                return;
            }
            if (!currentWatermarkVideo) {
                showMessageBox('Please upload a watermark PNG first.');
                return;
            }

            showMessageBox(`
                <strong class="text-red-600">WARNING: Client-side Video Processing Limitations!</strong><br><br>
                Full video watermarking with complex effects (fade, blur) and re-encoding is extremely resource-intensive and not efficiently possible for bulk operations directly in the browser without specialized, very large libraries (like FFmpeg compiled to WebAssembly) that can crash your browser.<br><br>
                This button will now download your **original videos in a ZIP file**. This serves as a placeholder for where truly processed and watermarked videos would go if a powerful server-side solution were available.
                <br><br>
                Preparing ZIP for download... This might take a moment.
            `);

            const zip = new JSZip();

            for (let i = 0; i < uploadedVideos.length; i++) {
                const file = uploadedVideos[i];
                // Add original video files directly to the zip
                const originalFileName = file.name;
                // You might want to rename them to indicate they *would* be watermarked
                const zipFileName = `(unwatermarked)_${originalFileName.replace(/\s/g, '_')}`;
                zip.file(zipFileName, file); // Add the Blob directly
            }

            // Generate and download the ZIP file
            zip.generateAsync({type: "blob"})
               .then(function(content) {
                   const a = document.createElement('a');
                   a.href = URL.createObjectURL(content);
                   a.download = 'original_videos_for_watermarking.zip';
                   document.body.appendChild(a);
                   a.click();
                   document.body.removeChild(a);
                   showMessageBox('All original video files have been zipped and downloaded. Remember, for actual watermarking, a server-side solution is needed!');
               })
               .catch(error => {
                   console.error('Error zipping videos:', error);
                   showMessageBox('Error creating ZIP file for videos. Please try again.');
               });
        });

        // Initialize state on load
        document.addEventListener('DOMContentLoaded', () => {
            switchTab('photo'); // Start with photo section
            // Ensure canvas is resized to fit its parent on load
            const photoPreviewArea = photoCanvas.closest('.preview-area');
            const videoPreviewArea = videoPreview.closest('.preview-area');

            // Set initial canvas size to match the preview area
            photoCanvas.width = photoPreviewArea.clientWidth;
            photoCanvas.height = photoPreviewArea.clientHeight;

            // Also re-draw/update overlays if the preview area resizes
            new ResizeObserver(() => {
                if (!photoSection.classList.contains('hidden')) { // Only update if photo section is active
                    // Recalculate canvas size based on new preview area dimensions
                    const currentSelectedFile = uploadedPhotos[currentSelectedPhotoIndex];
                    if (currentSelectedFile) {
                        const img = new Image();
                        img.onload = () => {
                            const maxWidth = photoPreviewArea.clientWidth;
                            const maxHeight = photoPreviewArea.clientHeight;

                            let aspectRatio = img.width / img.height;
                            let newWidth = img.width;
                            let newHeight = newWidth / aspectRatio; // Corrected calculation
                            if (newHeight > maxHeight) { // If it's still too tall
                                newHeight = maxHeight;
                                newWidth = newHeight * aspectRatio;
                            }
                             // Ensure it doesn't exceed max dimensions
                            if (newWidth > maxWidth) newWidth = maxWidth;
                            if (newHeight > maxHeight) newHeight = maxHeight;

                            photoCanvas.width = newWidth;
                            photoCanvas.height = newHeight;
                            drawPhotoWatermark();
                        };
                        img.src = URL.createObjectURL(currentSelectedFile);
                    } else {
                         photoCanvas.width = photoPreviewArea.clientWidth;
                         photoCanvas.height = photoPreviewArea.clientHeight;
                         photoCtx.clearRect(0, 0, photoCanvas.width, photoCanvas.height);
                    }
                }
                updateVideoWatermarkOverlay(); // This already has a resize observer
            }).observe(photoPreviewArea);
        });
    </script>
</body>
</html>
